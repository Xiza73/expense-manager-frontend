# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project Overview

**Habit Sumaq** is a modern expense management application built with React, TypeScript, and Vite. The app helps users track expenses, manage accounts, and handle transactions with support for multiple currencies, debts/loans, and partial payments.

## Development Commands

### Package Manager
This project uses **pnpm** as the package manager.

### Common Commands
```bash
# Install dependencies
pnpm install

# Development server (runs on port 4020)
pnpm dev

# Production build
pnpm build

# Preview production build
pnpm pre

# Linting
pnpm lint          # Check for linting errors
pnpm lint:fix      # Fix linting errors automatically

# Code formatting
pnpm format        # Format code with Prettier
```

### Environment Setup
1. Copy `.env.template` to `.env`
2. Set `VITE_API_URL` to your backend API URL (default: `http://localhost:3000/api`)
3. Set `VITE_FRONTEND_URL` to your frontend URL

## Code Architecture

### High-Level Structure

The codebase follows a **feature-based modular architecture** with domain-driven design principles:

```
src/
├── app/           # Feature modules (account, auth, transaction, service, etc.)
├── components/    # Shared UI components
├── routes/        # TanStack Router route definitions
├── store/         # Zustand stores for global state
├── hooks/         # Custom React hooks
├── domain/        # Shared domain types and interfaces
├── config/        # App configuration (env, axios interceptors)
├── lib/           # Third-party library setup (axios, i18n)
├── utils/         # Utility functions
└── assets/        # Static assets
```

### Feature Module Pattern

Each feature module in `src/app/` follows a consistent internal structure:

```
app/<feature>/
├── adapters/    # Transform API data to domain models
├── components/  # Feature-specific components
├── domain/      # Feature-specific types and interfaces
├── pages/       # Feature page components
├── queries/     # React Query hooks for data fetching
└── services/    # API service functions
```

**Example modules**: `account`, `transaction`, `auth`, `service`

### State Management Architecture

**Zustand stores** (in `src/store/`) manage global application state:
- `auth/` - Authentication and user state
- `darkMode/` - Theme preferences
- `loader/` - Loading state management
- `modal/` - Modal visibility and content
- `error/` - Error state management
- `transactionSearch/` - Transaction search/filter state

Each store follows the pattern:
- `<feature>.model.ts` - Type definitions
- `use<Feature>Store.tsx` - Zustand store implementation
- `use<Feature>.ts` - Custom hook with business logic

### Routing

**TanStack Router** with file-based routing:
- Routes are defined in `src/routes/`
- File naming convention: `<parent>.<child>.<params>.tsx`
  - Example: `account.$accountId.tsx` (route with accountId param)
  - Example: `transaction.create.$accountId.tsx` (nested route)
- `__root.tsx` defines the root layout and auth checks
- `routeTree.gen.ts` is auto-generated by the TanStack Router plugin

### Data Fetching Pattern

Custom hooks wrap TanStack Query with built-in loading/error handling:

**useQuery** (`src/hooks/useQuery.ts`):
- Wraps `@tanstack/react-query`'s `useQuery`
- Automatically integrates with global loader and error stores
- Options: `showLoading`, `showError`, `showPageError`, `showSuccess`

**useMutation** (`src/hooks/useMutation.ts`):
- Wraps `@tanstack/react-query`'s `useMutation`
- Automatic toast notifications on success/error
- Automatic loader management
- Options: `showSuccess`, `showError`, `showLoader`, `customSuccessMessage`, `customErrorMessage`

### API Layer

**Axios instance** (`src/lib/axios.ts`):
- Pre-configured with base URL from `env.config.ts`
- Interceptors for authentication tokens (`src/config/interceptors.config.ts`)
- Automatically adds Bearer token from localStorage

**API Service Pattern**:
- Services in feature modules (e.g., `app/account/services/`)
- Return promises with typed responses
- Adapters transform API responses to domain models

### Component Organization

**UI Components** (`src/components/ui/`):
- shadcn/ui components
- Radix UI primitives
- Consistent styling with Tailwind CSS + CVA

**Shared Components**:
- Form components with consistent validation (Zod + react-hook-form)
- Custom table with ordering/pagination (`CustomTable`)
- Layout components for consistent page structure

**Path Aliases**:
- Use `@/*` to import from `src/` (configured in `tsconfig.json` and `vite.config.ts`)
- Example: `import { api } from '@/lib/axios'`

### Internationalization

- Uses `i18next` and `react-i18next`
- Configured in `src/lib/i18n/`
- Supports multiple languages (Spanish, English)

### Styling

- **Tailwind CSS v4** with `@tailwindcss/vite` plugin
- Component variants with `class-variance-authority`
- Consistent dark mode support
- SCSS for complex styles (modern compiler API)

### Type Safety

- **Strict TypeScript** configuration
- Domain models separate API types from UI types
  - `Api<Feature>` interfaces for backend responses
  - `<Feature>` interfaces for frontend domain models
- Zod schemas for form validation and runtime type checking

## Code Style and Conventions

### Import Ordering
ESLint enforces import sorting with `simple-import-sort`:
1. External packages
2. Internal imports (using `@/` alias)
3. Relative imports

### React Patterns
- Functional components with hooks
- Max 1 prop per line (enforced by ESLint)
- No unused variables (prefix with `_` if needed)

### File Naming
- Components: PascalCase (e.g., `FormButton.tsx`)
- Utilities: kebab-case with `.util.ts` suffix
- Domain types: kebab-case with `.interface.ts` or `.enum.ts`
- Stores: `use<Feature>Store.tsx` or `use<Feature>.ts`

### Component Props
- Use TypeScript interfaces for prop definitions
- Prefer destructuring in function parameters
- Mark optional props explicitly with `?`

## Key Technical Decisions

1. **TanStack Router over React Router**: Type-safe routing with automatic code-splitting
2. **Zustand over Redux**: Simpler state management with less boilerplate
3. **Custom query/mutation hooks**: Centralized loading/error handling reduces repetition
4. **Feature-based modules**: Better code organization and scalability
5. **API/Domain separation**: Clean boundary between backend contracts and frontend models
6. **pnpm**: Faster, more efficient package management
